---
title: 第三方模块
date: 2022-01-20 10:33:41
tags:
 - web
 - NodeJs
categories:
 - web
 - NodeJs
---

# 第三方模块

> 别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。

### 第三方模块存在形式

1. 以js文件的形式存在，提供实现项目具体功能的API接口。
2. 以命令行工具形式存在，辅助项目开发





### 第三方模块的获取

> npm (node package manager) ： node的第三方模块管理工具

#### npm操作

**下载：**`npm install 模块名称`

**卸载：**`npm unintall package 模块名称`

## 第三方模块

### nodemon

> nodemon是一个命令行工具，用以辅助项目开发。
>
> 在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐。

### nrm

> nrm ( npm registry manager )：npm下载地址切换工具

```js
查询可用下载地址列表 nrm ls
切换npm下载地址 nrm use 下载地址名称
```

### Gulp

> 基于node平台开发的前端构建工具，将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。

#### Gulp使用

1. 下载gulp库文件`npm install gulp`
2. 在项目根目录下建立`gulpfile.js`文件
3. 重构项目的文件夹结构` src`目录放置源代码文件 `dist`目录放置构建后文件
4. 在`gulpfile.js`文件中编写任务.
5. 在命令行工具中执行gulp任务

#### Gulp提供的方法

1. gulp.src()：获取任务要处理的文件

2. gulp.dest()：输出文件

3. gulp.task()：建立gulp任务

4. gulp.watch()：监控文件的变化

```js
 const gulp = require('gulp');
  // 使用gulp.task()方法建立任务
 gulp.task('first', () => {
    // 获取要处理的文件
    gulp.src('./src/css/base.css') 
    // 将处理后的文件输出到dist目录
    .pipe(gulp.dest('./dist/css'));
 });
```

#### Gulp插件

- gulp-htmlmin ：html文件压缩
- gulp-csso ：压缩css
- gulp-babel ：JavaScript语法转化
- gulp-less: less语法转化
- gulp-uglify ：压缩混淆JavaScript
- gulp-file-include 公共文件包含
- browsersync 浏览器实时同步





### 模板引擎artTemplate

> 让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更加易于维护。

```js
 // 未使用模板引擎的写法
 var ary = [{ name: '张三', age: 20 }];
 var str = '<ul>';
 for (var i = 0; i < ary.length; i++) { 
    str += '<li>\
        <span>'+ ary[i].name +'</span>\
        <span>'+ ary[i].age +'</span>\
    </li>';
 }
 str += '</ul>'; 

```

```js
 <!-- 使用模板引擎的写法 --> 
 <ul>
    {{each ary}}
        <li>{{$value.name}}</li>
        <li>{{$value.age}}</li>
    {{/each}}
 </ul>
```

#### art-template模板引擎

1. 在命令行工具中使用 `npm install art-template` 命令进行下载

2. 使用`const template = require('art-template')`引入模板引擎

3. 告诉模板引擎要拼接的数据和模板在哪` const html = template(‘模板路径’, 数据)`;

4. 使用模板语法告诉模板引擎，模板与数据应该如何进行拼接 

```js
 // 导入模板引擎模块
 const template = require('art-template');
 // 将特定模板与特定数据进行拼接
 const html = template('./views/index.art',{
    data: {
        name: '张三',
        age: 20
    }
 }); 
```

```html
 <div>
    <span>{{data.name}}</span>
    <span>{{data.age}}</span>
 </div>
```



#### 模板引擎语法

##### 模板语法

- art-template同时支持两种模板语法：标准语法和原始语法。

  ```html
  {{ 数据 }}
  ```

- 标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力。

  ```html
  <%=数据 %>
  ```

```html
  <!-- 标准语法 -->
 <h2>{{value}}</h2>
 <h2>{{a ? b : c}}</h2>
 <h2>{{a + b}}</h2>

  <!-- 原始语法 -->
 <h2><%= value %></h2>
 <h2><%= a ? b : c %></h2>
 <h2><%= a + b %></h2>
```

##### 原文输出

> 如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出。

```html
 <!-- 标准语法 -->
 <h2>{{@ value }}</h2>
 <!-- 原始语法 -->
 <h2><%- value %></h2>
```

##### 条件判断

```html
 <!-- 标准语法 --> 
 {{if 条件}} ... {{/if}}
 {{if v1}} ... {{else if v2}} ... {{/if}}
 <!-- 原始语法 -->
 <% if (value) { %> ... <% } %>
 <% if (v1) { %> ... <% } else if (v2) { %> ... <% } %>
```

##### 循环

```html
 <!-- 标准语法 -->
 {{each target}}
     {{$index}} {{$value}}
 {{/each}}
  <!-- 原始语法 -->
 <% for(var i = 0; i < target.length; i++){ %>
     <%= i %> <%= target[i] %>
 <% } %>
```

##### 子模版

> 使用子模板可以将网站公共区块(头部、底部)抽离到单独的文件中。

```js
  <!-- 标准语法 -->
 {{include './header.art'}}
  <!-- 原始语法 -->
 <% include('./header.art') %>
```

##### 模板继承

>  使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件。

![image-20220128113124710](https://raw.githubusercontent.com/cloutp/blog_img/main/202201281131994.png)

​	**示例：**

1. 模板

   ```html
    <!doctype html>
    <html>
        <head>
            <meta charset="utf-8">
            <title>HTML骨架模板</title>
            {{block 'head'}}{{/block}}
        </head>
        <body>
            {{block 'content'}}{{/block}}
        </body>
    </html>
   ```

2. 继承

   ```html
    <!--index.art 首页模板-->
    {{extend './layout.art'}}
    {{block 'head'}} <link rel="stylesheet" href="custom.css"> {{/block}}
    {{block 'content'}} <p>This is just an awesome page.</p> {{/block}}
   
   ```

   

#### 模板配置

1. 向模板中导入变量 template.defaults.imports.变量名 = 变量值;

2. 设置模板根目录 template.defaults.root = 模板目录

3. 设置模板默认后缀 template.defaults.extname = '.art'



### 路由Router

**使用步骤：**

1. 获取路由对象

2. 调用路由对象提供的方法创建路由

3. 启用路由，使路由生效



```js
const getRouter = require('router')
const router = getRouter();
router.get('/add', (req, res) => {
    res.end('Hello World!')
}) 
server.on('request', (req, res) => {
    router(req, res)
})

```





### 静态资源serve-static

>  实现静态资源访问服务

**步骤：**

1. 引入serve-static模块获取创建静态资源服务功能的方法

2. 调用方法创建静态资源服务并指定静态资源服务目录

3. 启用静态资源服务功能

```js
const serveStatic = require('serve-static')
const serve = serveStatic('public')
server.on('request', () => { 
    serve(req, res)
})
server.listen(3000)
```





### Express框架

> Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。使用 `npm install express` 命令进行下载。

#### 框架特性

1. 提供了方便简洁的路由定义方式
2. 对获取HTTP请求参数进行了简化处理
3. 对模板引擎支持程度高，方便渲染动态HTML页面
4. 提供了中间件机制有效控制HTTP请求
5. 拥有大量第三方中间件对功能进行扩展

#### 对比

**原生**

```js
 app.on('request', (req, res) => {
     // 获取客户端的请求路径
     let { pathname } = url.parse(req.url);
     // 对请求路径进行判断 不同的路径地址响应不同的内容
     if (pathname == '/' || pathname == 'index') {
        res.end('欢迎来到首页');
     } else if (pathname == '/list') {
        res.end('欢迎来到列表页页');
     } else if (pathname == '/about') {
        res.end('欢迎来到关于我们页面')
     } else {
        res.end('抱歉, 您访问的页面出游了');
     }
     // 获取GET参数
    let {query} = url.parse(req.url, true);
    // 获取POST参数
    let postData = '';
    req.on('data', (chunk) => {
        postData += chunk;
    });
    req.on('end', () => {
        console.log(querystring.parse(postData)
    })); 

 });
```

**框架**

```js
// 当客户端以get方式访问/时
app.get('/', (req, res) => {
    // 获取GET参数
    console.log(req.query);

 // 对客户端做出响应
 res.send('Hello Express');
});

// 当客户端以post方式访问/add路由时
app.post('/add', (req, res) => {
        // 获取POST参数
    console.log(req.body);

res.send('使用post方式请求了/add路由');
});
```

#### 框架使用

```js
 // 引入Express框架
 const express = require('express');
 // 使用框架创建web服务器
 const app = express();
 // 当客户端以get方式访问/路由时
 app.get('/', (req, res) => {
    // 对客户端做出响应 send方法会根据内容的类型自动设置请求头
    res.send('Hello Express'); // <h2>Hello Express</h2> {say: 'hello'}
 });
 // 程序监听3000端口
 app.listen(3000);
```

#### 中间件

> 中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。

![image-20220128114633703](https://raw.githubusercontent.com/cloutp/blog_img/main/202201281146880.png)

> 中间件主要由两部分构成，中间件方法以及请求处理函数。

> 中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。

```js
 app.get('请求路径', '处理函数')   // 接收并处理get请求
 app.post('请求路径', '处理函数')  // 接收并处理post请求
```

> 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。

```js
 app.get('/request', (req, res, next) => {
     req.name = "张三";
     next();
 });
 app.get('/request', (req, res) => {
     res.send(req.name);
 });
```

##### app.use中间件

> app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求

```js
 app.use((req, res, next) => {
     console.log(req.url);
     next();
 });
```

>  app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。

```js
 app.use('/admin', (req, res, next) => {
     console.log(req.url);
     next();
 });
```

##### 错误处理中间件

> 在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。

```js
 app.use((err, req, res, next) => {
     res.status(500).send('服务器发生未知错误');
 })
```

> 当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。

```js
 app.get("/", (req, res, next) => {
     fs.readFile("/file-does-not-exist", (err, data) => {
         if (err) {
            next(err);
         }
     });
});
```

**捕获错误**

> 在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获

> try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。

```js
 app.get("/", async (req, res, next) => {
     try {
         await User.find({name: '张三'})
     }catch(ex) {
         next(ex);
     }
 });
```



##### 中间件应用

1. 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。

2. 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。

3. 自定义404页面



#### 构建模块化路由

```js
 const express = require('express') 
 // 创建路由对象
 const home = express.Router();
 // 将路由和请求路径进行匹配
 app.use('/home', home);
  // 在home路由下继续创建路由
 home.get('/index', () => {
          //  /home/index
         res.send('欢迎来到博客展示页面');
 });
```

1. app.js

   ```js
    // app.js
    const home = require('./route/home.js');
    const admin = require('./route/admin.js');
    app.use('/home', home);
    app.use('/admin', admin);
   
   ```

2. home.js

   ```js
    // home.js
    const home = express.Router(); 
    home.get('/index', () => {
        res.send('欢迎来到博客展示页面');
    });
    module.exports = home;
   ```

3. admin.js

   ```js
    // admin.js
    const admin = express.Router();
    admin.get('/index', () => {
        res.send('欢迎来到博客管理页面');
    });
    module.exports = admin;
   ```

#### GET参数的获取

> Express框架中使用**req.query**即可获取GET参数，框架内部会将GET参数转换为对象并返回。

```js
 // 接收地址栏中问号后面的参数
 // 例如: http://localhost:3000/?name=zhangsan&age=30
 app.get('/', (req, res) => {
    console.log(req.query); // {"name": "zhangsan", "age": "30"}
 });
```

#### POST参数的获取

> Express中接收post请求参数需要借助第三方包 body-parser。

```js
 // 引入body-parser模块
 const bodyParser = require('body-parser');
 // 配置body-parser模块
 app.use(bodyParser.urlencoded({ extended: false }));
 // 接收请求
 app.post('/add', (req, res) => {
    // 接收请求参数
    console.log(req.body);
 }) 
```

#### Express路由参数

```js
// localhost:3000/find/123
app.get('/find/:id', (req, res) => { 
     console.log(req.params); // {id: 123} 
 });
```

#### 静态资源的处理

> 通过Express内置的**express.static**可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。

```js
 app.use(express.static('public'));
```

#### express-art-template模板引擎

- 为了使`art-template`模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了`express-art-template`。

- 使用`npm install art-template express-art-template`命令进行安装

```js
  // 当渲染后缀为art的模板时 使用express-art-template
 app.engine('art', require('express-art-template'));
  // 设置模板存放目录
 app.set('views', path.join(__dirname, 'views'));
  // 渲染模板时不写后缀 默认拼接art后缀
 app.set('view engine', 'art');
 app.get('/', (req, res) => {
     // 渲染模板
     res.render('index');
 }); 
```



#### app.locals 对象

> 将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。

```js
 app.locals.users = [{
     name: '张三',
     age: 20
 },{
     name: '李四',
     age: 20
}]
```



### config模块

> 允许开发人员将不同运行环境下的应用配置信息抽离到单独的文件中，模块内部自动判断当前应用的运行环境，并读取对应的配置信息，极大提供应用配置信息的维护成本，避免了当运行环境重复的多次切换时，手动到项目代码中修改配置信息

**使用步骤**

1. 使用npm install config命令下载模块

2. 在项目的根目录下新建config文件夹

3. 在config文件夹下面新建default.json、development.json、production.json文件

4. 在项目中通过require方法，将模块进行导入

5. 使用模块内部提供的get方法获取配置信息





### 密码加密 bcrypt

```js
// 导入bcrypt模块
const bcrypt = require('bcrypt');
// 生成随机字符串 gen => generate 生成 salt 盐
let salt = await bcrypt.genSalt(10);
// 使用随机字符串对密码进行加密
let pass = await bcrypt.hash('明文密码', salt);
```

```js
// 密码比对
let isEqual = await bcrypt.compare('明文密码', '加密密码');
```

bcrypt依赖的其他环境

1. python 2.x

2. node-gyp

   `npm install -g node-gyp`

3. windows-build-tools

   `npm install --global --production windows-build-tools`



### express-session

cookie：浏览器在电脑硬盘中开辟的一块空间，主要供服务器端存储数据。

1. cookie中的数据是以域名的形式进行区分的。

2. cookie中的数据是有过期时间的，超过时间数据会被浏览器自动删除。

3. cookie中的数据会随着请求被自动发送到服务器端。

session：实际上就是一个对象，存储在服务器端的内存中，在session对象中也可以存储多条数据，每一条数据都有一个sessionid做为唯一标识。



![image-20220128120649920](https://raw.githubusercontent.com/cloutp/blog_img/main/202201281206243.png)

```js
const session = require('express-session');
app.use(session({ secret: 'secret key' }));
```



### **Joi** 

> JavaScript对象的规则描述语言和验证器。

```js
const Joi = require('joi');
const schema = {
    username: Joi.string().alphanum().min(3).max(30).required().error(new Error(‘错误信息’)),
    password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
    access_token: [Joi.string(), Joi.number()],
    birthyear: Joi.number().integer().min(1900).max(2013),
    email: Joi.string().email()
};
Joi.validate({ username: 'abc', birthyear: 1994 }, schema);
```



### formidable

> 解析表单，支持get请求参数，post请求参数、文件上传。

```js
 // 引入formidable模块
 const formidable = require('formidable');
 // 创建表单解析对象
 const form = new formidable.IncomingForm();
 // 设置文件上传路径
 form.uploadDir = "/my/dir";
 // 是否保留表单上传文件的扩展名
 form.keepExtensions = false;
 // 对表单进行解析
 form.parse(req, (err, fields, files) => {
     // fields 存储普通请求参数
         // files 存储上传的文件信息
 });
```





### **文件读取** FileReader

```js
 var reader = new FileReader();
 reader.readAsDataURL('文件');
 reader.onload = function () {
     console.log(reader.result); 
 }
```



### 数据分页 mongoose-sex-page

```js
const pagination = require('mongoose-sex-page');
pagination(集合构造函数).page(1) .size(20) .display(8) .exec();
```

